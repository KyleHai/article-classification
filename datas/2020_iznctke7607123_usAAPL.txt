苹果M1预示着RISC-V的崛起？
格隆汇APP
<p cms-style="font-L">来源：<font cms-style="font-L">半导体行业观察</font></p><p cms-style="font-L"><font cms-style="font-L">到目前为止，很明显，苹果的M1芯片是一件大事。而且，对其他行业的影响也越来越清晰。在这个故事中，我想谈谈这件事对RISC-V微处理器的影响，而这对于大多数读者而言可能并不明显。</font></p><p cms-style="font-L">Apple积极追求添加专用硬件单元的策略，在本文中，我将其称为协处理器：</p><p cms-style="font-L"><font cms-style="font-L">GPU（图形处理单元），用于图形和许多其他具有大量数据并行性的任务（同时对多个元素执行相同的操作）。</font></p><p cms-style="font-L"><font cms-style="font-L">神经引擎。用于机器学习的专用硬件。</font></p><p cms-style="font-L"><font cms-style="font-L">用于图像处理的数字信号处理硬件（DSP）。</font></p><p cms-style="font-L"><font cms-style="font-L">硬件中的视频编码。</font></p><p cms-style="font-L"><font cms-style="font-L">在苹果的解决方案中，他们并没有添加更多的通用处理器，而是开始在解决方案中添加更多的协处理器。在这里，您也可以使用专用的术语——加速器。</font></p><p cms-style="font-L"><font cms-style="font-L">这不是一个全新的趋势，我从1985年开始使用的老式Amiga 1000具有协处理器来加速音</font><font cms-style="font-L">频和图形。</font><font cms-style="font-L">现代GPU本质上是协处理器。</font><font cms-style="font-L">Google的Tensor处理单元是一种用于机器学习的协处理器。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">什么是协处理器？</font></font></p><p cms-style="font-L"><font cms-style="font-L">与CPU不同，协处理器不能单独存在。您不能仅通过将协处理器插入其中来制造计算机。协处理器作为专用处理器，可以很好地完成特定任务。协处理器的最早示例之一是Intel 8087浮点单元（FPU）。不起眼的Intel 8086微处理器可以执行整数运算，但不能执行浮点运算。有什么不同？</font></p><p cms-style="font-L"><font cms-style="font-L">整数是这样的整数：43, -5, 92, 4。</font></p><p cms-style="font-L"><font cms-style="font-L">这些对于计算机来说相当容易使用。您可能会自己组合一个解决方案，以使用一些简单的筹码相加整数。但当您需要小数时，问题就开始了。</font></p><p cms-style="font-L"><font cms-style="font-L">假设您要对类似4.25, 84.7 or 3.1415这样的数字进行加法或乘法运算。因为这些是浮点数的示例。如果该点之后的位数是固定的，我们将其称为固定点号。金钱常常被这样对待。您通常在该点后有两位小数。</font></p><p cms-style="font-L"><font cms-style="font-L">当然，您可以使用整数来模拟浮点运算，但是速度较慢。这类似于早期的微处理器也不能够将整数相乘。他们只能加减。但是，仍然可以执行乘法。您只需要模拟它将添加多个内容。例如3 × 4简单4 + 4 + 4。</font></p><p cms-style="font-L"><font cms-style="font-L">理解下面的代码示例并不重要，但是它可以帮助您了解CPU如何仅通过使用加，减和分支（代码跳转）来执行乘法。</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/534/w1080h254/20201221/cc11-kfnaptu5546599.jpg" w="1080" h="254" wh="4.25"/></div><p cms-style="font-L"><font cms-style="font-L">简而言之，您总是可以通过重复简单的运算来实现更复杂的数学运算。</font></p><p cms-style="font-L"><font cms-style="font-L">所有协处理器的工作与此相似。CPU总是有一种方法可以完成与协处理器相同的任务。但是，这通常需要重复多个更简单的操作。我们之所以提早使用GPU是因为，对数百万个多边形或像素重复相同的计算对于CPU来说确实很耗时。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">如何与协处理器传输数据</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">让我们看一下下面的图，以更好地了解协处理器是如何与微处理器（CPU）或通用处理器一起工作。</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/266/w1080h786/20201221/b1d5-kfnaptu5546603.png" w="1080" h="786" wh="1.37"/></div><p cms-style="font-L"><font cms-style="font-L">微处理器工作原理概述。数字沿彩色线移动。输入/输出可以是协处理器，鼠标，键盘和其他设备。</font></p><p cms-style="font-L"><font cms-style="font-L">我们可以将绿色和浅蓝色的总线视为管道。通过这些管道，我们可以将数字推送到CPU的不同功能单元（绘制为灰色框）。这些盒子的输入和输出连接到这些管道。您可以认为每个盒子的输入和输出都有阀门（（ valves））。红色控制线用于打开和关闭这些阀（（ valves））。因此，负责红线的解码器可以打开两个灰色框上的阀（valves），使数字在它们之间流动。</font></p><p cms-style="font-L"><font cms-style="font-L">您可以将数据总线视为带有由红色控制线打开和关闭的阀门（ valves）的管道。但是，在电子设备中，这是通过我们所谓的多路复用器完成的，而不是实际的阀门。</font></p><p cms-style="font-L"><font cms-style="font-L">这让我们解释了如何从内存中获取数据。要对数字执行运算，我们需要在寄存器中进行操作。</font></p><p cms-style="font-L"><font cms-style="font-L strong-Bold"><font cms-style="font-L strong-Bold">该解码器使用控制线，以打开灰色存储器框和寄存器框的阀门（ valves）。</font></font><font cms-style="font-L">具体是这样的：</font></p><p cms-style="font-L"><font cms-style="font-L">1、解码器打开负载存储单元（Load Store Unit :LSU）上的阀，该阀使内存地址从绿色地址总线上流出。</font></p><p cms-style="font-L"><font cms-style="font-L">2、内存盒上的另一个阀门被打开，因此它可以接收地址。它由绿色管道（地址总线）传送。所有其他阀都关闭，因此例如输入/输出无法接收地址。</font></p><p cms-style="font-L"><font cms-style="font-L">3、选择具有给定地址的存储单元。它的内容流出到蓝色数据总线上，因为解码器已经打开了通往数据总线的阀门。</font></p><p cms-style="font-L"><font cms-style="font-L">4、存储单元中的数据可以流到任何地方，但是解码器仅打开了寄存器的输入阀。</font></p><p cms-style="font-L"><font cms-style="font-L">诸如鼠标，键盘，屏幕，GPU，FPU，神经引擎和其他协处理器之类的东西都等于“输入/输出”框。我们像访问存储位置一样访问它们。硬盘驱动器，鼠标，键盘，网卡，GPU，DMA（直接内存访问）和协处理器都具有映射到它们的内存地址。</font></p><p cms-style="font-L"><font cms-style="font-L">通过指定地址，我们可以像访问存储位置一样访问硬件。</font></p><p cms-style="font-L"><font cms-style="font-L">通过这些举例，你能看懂我到底想说明什么？如果没有，让我补充一些地址。如果处理器尝试从内存地址84读取，则可能意味着计算机鼠标的x坐标。虽然说85表示y坐标。因此，要获取鼠标坐标，您可以在汇编代码中执行以下操作：</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/451/w1080h171/20201221/e8cb-kfnaptu5546814.jpg" w="1080" h="171" wh="6.32"/></div><p cms-style="font-L"><font cms-style="font-L">对于DMA控制器，可能会有地址110、111和113，这是特殊含义。这是一个不切实际的汇编代码程序，使用该程序与DMA控制器进行交互：</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/571/w1080h291/20201221/47df-kfnaptu5546816.jpg" w="1080" h="291" wh="3.71"/></div><p cms-style="font-L"><font cms-style="font-L">一切都以这种方式工作。您读写特殊的内存地址。当然，常规的软件开发人员从来没有看到过这种情况。这些工作由设备驱动程序完成。您使用的程序只能看到不可见的虚拟内存地址。但是驱动程序会将这些地址映射到其虚拟内存地址。</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/72/w583h289/20201221/73e5-kfnaptu5547051.png" w="583" h="289" wh="2.02"/></div><p cms-style="font-L"><font cms-style="font-L">我不会过多地谈论虚拟内存。本质上，我们得到了真实的地址。绿色总线上的地址将从虚拟地址转换为实际物理地址。当我开始在DOS中使用C / C ++进行编程时，没有这种东西。我可以将C指针设置为直接指向视频内存的内存地址，然后开始直接向其写入以更改图片。</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/456/w1080h176/20201221/039c-kfnaptu5547053.jpg" w="1080" h="176" wh="6.14"/></div><p cms-style="font-L"><font cms-style="font-L">协处理器的工作方式与此相同。</font></p><p cms-style="font-L"><font cms-style="font-L">神经引擎，GPU，安全区域等将具有您与之通信的地址。了解这些以及诸如DMA控制器之类的重要信息是让它们可以异步工作。</font></p><p cms-style="font-L"><font cms-style="font-L">这意味着CPU可以为神经引擎或GPU安排一堆完整的指令，并将其写入内存中的缓冲区。然后，通过与它们的IO地址进行对话，将这些指令的位置通知神经引擎或GPU协处理器。</font></p><p cms-style="font-L"><font cms-style="font-L">您不希望CPU坐在那里闲置等待协处理器检查所有指令和数据。您也不想使用DMA进行操作。这就是为什么通常您可以提供某种中断的原因。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">中断如何工作？</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">在实际操作中，当您在PC中插入各种卡（无论是图形卡还是网卡）后，它们都将获得分配一些中断线。就像一条直线直接进入您的CPU。激活此行后，CPU会将其持有的所有内容都丢弃以处理中断。</font></p><p cms-style="font-L"><font cms-style="font-L">或更具体地说。它在内存中存储其当前位置及其寄存器的值，因此可以返回到以后执行的操作。</font></p><p cms-style="font-L"><font cms-style="font-L">接下来，它在所谓的中断表中查找要做什么。该表具有触发该中断时要运行的程序的地址。</font></p><p cms-style="font-L"><font cms-style="font-L">作为程序员，您不会看到这些东西。对您来说，它看起来更像是为某些事件注册的回调函数。驱动程序通常在较低级别上进行处理。</font></p><p cms-style="font-L"><font cms-style="font-L">我为什么要告诉你所有这些书呆子的细节？因为它有助于您了解使用协处理器时发生的情况。否则，不清楚与协处理器进行通信实际上需要做什么。</font></p><p cms-style="font-L"><font cms-style="font-L">使用中断可以使许多事情并行发生。当CPU被计算机鼠标中断时，应用程序可能会从网卡获取图像。鼠标已移动，我们需要新的坐标。CPU可以读取这些并将它们发送到GPU，因此可以在新位置重新绘制鼠标光标。当GPU绘制鼠标光标时，CPU可以开始处理从网络检索到的图像。</font></p><p cms-style="font-L"><font cms-style="font-L">同样，通过这些中断，我们可以将复杂的机器学习任务发送给M1神经引擎，以识别网络摄像头上的人脸。同时，计算机的其余部分都响应，因为神经引擎正在与CPU所做的其他所有事情并行地浏览图像数据。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">RISC-V的兴起</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">早在2010年，在加州大学伯克利分校的并行计算实验室（ Parallel Computing Laboratory），我们看到了向大量使用协处理器发展的趋势。因为他们看到，当摩尔定律走向终结时，意味着您不再能够轻易地从通用CPU内核中挤出更多性能。因此您需要专用的硬件：协处理器。</font></p><p cms-style="font-L"><font cms-style="font-L">让我们暂时反思一下为什么。我们知道，时钟频率不能轻易增加，我们被困在3–5 GHz这个频率范围很久了。任何频率的升高都会带来能量消耗和热量小号。</font></p><p cms-style="font-L"><font cms-style="font-L">但是，我们可以添加更多的晶体管，不过我们根本无法使晶体管工作得更快。因此，我们需要并行进行更多工作。一种方法是添加大量通用内核。正如我之前讨论的那样，我们可以添加很多解码器并执行乱序执行（OoOE）。</font></p><p cms-style="font-L">您可以继续传统玩法，让你的CPU最终拥有128个通用内核，例如Ampere Altra Max ARM处理器。但这真的是我们硅的最佳用途吗？毫无疑问，对于云中的服务器而言，这很棒。因为我们可以使所有这128个内核忙于处理各种客户端请求。但是，台式机系统可能无法有效地在普通台式机工作负载上使用8个以上的内核。因此，如果您说32核，则是浪费了很多时间会闲置的许多核上的硅。</p><p cms-style="font-L"><font cms-style="font-L">与其将所有的芯片都花在更多的CPU核上，不如我们可以添加更多的协处理器？</font></p><p cms-style="font-L"><font cms-style="font-L">这样考虑：您有一个晶体管预算。在早期，也许您的预算为2万个晶体管，并且您认为可以使CPU具有15000个晶体管。这在80年代初已经接近现实。现在，该CPU可以执行100个不同的任务。假设为其中一项任务制作专用的协处理器，将花费1000个晶体管。如果您为每个任务创建一个协处理器，那么您将获得10万个晶体管。那会浪费你的预算。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">晶体管丰度变化策略</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">因此，在早期设计中，需要专注于通用计算。但是今天，我们可以用许多晶体管填充芯片，我们几乎不知道该怎么办。</font></p><p cms-style="font-L"><font cms-style="font-L">因此，设计协处理器已成为一件大事。进行各种新型协处理器的研究很多。但是，这些往往包含漂亮却笨拙的加速器，这需要改进。与CPU不同，它们无法读取告诉他们所有步骤的指令。他们通常不知道如何访问内存和组织任何事情。</font></p><p cms-style="font-L"><font cms-style="font-L">因此，对此的常见解决方案是使用简单的CPU作为一种控制器。因此，整个协处理器是由一个简单的CPU控制的专用加速器电路，该电路配置加速器以完成其工作。通常这是高度专业化的。例如，诸如神经引擎或张量处理单元之类的东西处理的是非常大的寄存器，可以容纳矩阵（行和数字列）。</font></p><p cms-style="font-L">这正是RISC-V设计的目的。它仅有约40至50条指令的最小指令集，这使其可以执行所有典型的CPU工作。听起来可能很多，但是请记住，x86 CPU具有超过1500条指令。</p><p cms-style="font-L"><font cms-style="font-L">与大量的固定指令集不一样，RISC-V是围绕扩展的概念设计的。每个协处理器都是不同的。因此，它将包含一个RISC-V处理器来管理实现核心指令集的事物以及针对该协处理器需要做什么而定制的扩展指令集。</font></p><p cms-style="font-L"><font cms-style="font-L">好吧，现在也许您开始看到我正在了解的轮廓。苹果的M1确实将推动整个行业朝着这个协处理器主导的未来发展。为了制造这些协处理器，RISC-V将成为解决难题的重要组成部分。</font></p><p cms-style="font-L"><font cms-style="font-L">但为什么？制作协处理器的每个人都不能只是发明自己的指令集吗？毕竟，我认为苹果已经做到了。或者可能他们使用ARM。我不知道。如果有人知道，请给我打个电话。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">坚持使用RISC-V进行协处理器设计有什么好处？</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">制造芯片已成为一件复杂而昂贵的事情。建立工具以验证您的芯片。运行测试程序，诊断和许多其他事情需要很多努力。这是当今使用ARM的价值的一部分。他们拥有庞大的工具生态系统，可帮助您验证设计并对其进行测试。</font></p><p cms-style="font-L"><font cms-style="font-L">因此，寻求定制的专有指令集不是一个好主意。但是，使用RISC-V可以为多家公司提供标准工具。突然有一个生态系统，多家公司可以分担负担。</font></p><p cms-style="font-L"><font cms-style="font-L">但是，为什么不使用现有的ARM呢？您会看到ARM被制成通用CPU。它具有较大的固定指令集。在客户和RISC-V竞争的压力下，ARM放松了态度，并于2019年开放了扩展指令集。但这仍然存在的问题是，因为它不是一开始就为此目的而设计的。整个ARM工具链将假定您已实现了整个大型ARM指令集。这对于Mac或iPhone的主CPU来说很好。</font></p><p cms-style="font-L"><font cms-style="font-L">但是对于协处理器，您不需要或不需要这么大的指令集。您需要一个围绕最小扩展基础固定扩展指令集这一思想构建的工具生态系统。</font></p><p cms-style="font-L"><font cms-style="font-L">为什么会有这样的好处？英伟达对RISC-V的使用提供了一些见识。在大型GPU上，他们需要某种通用CPU用作控制器。但是，他们可以为此预留一定数量的硅，并且允许产生的热量极小。请记住，许多事物正在争夺空间。</font></p><p cms-style="font-L"><font cms-style="font-L">RISC-V的小而简单的指令集使其可以以以比ARM少得多的硅实现RISC-V内核。</font></p><p cms-style="font-L"><font cms-style="font-L">由于RISC-V的指令集如此小而简单，因此它击败了包括ARM在内的所有竞争对手。Nvidia发现，选择RISC-V可以制造出比其他任何产品都小的芯片。他们还将功耗降至最低。</font></p><p cms-style="font-L"><font cms-style="font-L">因此，通过扩展机制，您可以将自己限制为仅添加对您需要完成的工作至关重要的指令。用于GPU的控制器可能需要除加密协处理器上的控制器以外的其他扩展。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">ARM将成为新的x86</font></font></font></p><p cms-style="font-L"><font cms-style="font-L">因此，具有讽刺意味的是，我们可能会看到Mac和PC由ARM处理器驱动的未来。但是在所有定制硬件周围，所有协处理器将由RISC-V主导。随着协处理器越来越流行，片上系统（SoC）中的硅芯片可能是运行RISC-V，而不是Arm。</font></p><p cms-style="font-L"><font cms-style="font-L">当我写上面的故事时，我实际上并没有完全理解RISC-V的全部含义。尽管未来将与ARM或RISC-V有关。相反，它可能是ARM和RISC-V。</font></p><p cms-style="font-L">通用ARM处理器将会是RISC-V驱动的协处理器的中心，以加速从图形，加密，视频编码，机器学习，信号处理到处理网络程序包的所有可能任务。</p><p cms-style="font-L"><font cms-style="font-L">David Patterson教授和他在加州大学伯克利分校的团队看到了这一未来的来临，这就是RISC-V如此精心定制以迎接这个新世界的原因。我们看到RISC-V在各种专用硬件和微控制器中得到了如此广泛的应用和关注，我认为当今ARM主导的许多领域都将成为RISC-V的天下。</font></p><div class="img_wrapper"><img src="http://n.sinaimg.cn/sinakd20201221s/155/w1080h675/20201221/fffb-kfnaptu5547254.jpg" w="1080" h="675" wh="1.60"/><span class="img_descr">RaspberryPi 4微控制器，当前使用ARM处理器</span></div><p cms-style="font-L"><font cms-style="font-L">想象一下类似Raspberry Pi的东西。现在它运行在ARM芯片上。但是未来的RISC-V变体可能会提供满足不同需求的大量变体。可能有机器学习微控制器。另一个可以是面向图像处理的。三分之一可能用于加密。基本上，您可以选择带有自己风格的微控制器。您可能可以在其上运行Linux并执行所有相同的任务，只是性能配置文件会有所不同。</font></p><p cms-style="font-L"><font cms-style="font-L">具有特殊机器学习指令的RISC-V微控制器将比具有视频编码指令的RISC-V微控制器更快地训练神经网络。</font></p><p cms-style="font-L"><font cms-style="font-L">英伟达已经通过他们的Jetson Nano冒险走这条路，如下所示。它是Raspberry Pi大小的微控制器，具有用于机器学习的专用硬件，因此您可以执行对象检测，语音识别和其他机器学习任务。</font></p><p cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center"><font cms-style="font-L strong-Bold align-Center">RISC-V作为主CPU？</font></font></p><p cms-style="font-L"><font cms-style="font-L">许多人问：为什么不用RISC-V完全替代ARM？尽管其他人则认为这将永远无法实现，因为RISC-V具有“微妙且简单”的指令集，无法提供ARM和x86提供的那种高性能。</font></p><p cms-style="font-L"><font cms-style="font-L">是的，您可以使用RISC-V作为主处理器。性能也不能阻止我们这样做。就像使用ARM一样，我们只需要有人来制造高性能RISC-V芯片。实际上，它可能已经完成了。之前又一家公司已经生成，他们新的RISC-V CPU获得了创纪录的每瓦性能。</font></p><p cms-style="font-L"><font cms-style="font-L">常见的误解是复杂的指令可以提供更高的性能。RISC工作站在90年代就证明了这一点，因为它们破坏了性能基准测试中的x86计算机。英特尔在90年代也战胜了很多RISC工作站。实际上，RISC-V有很多巧妙的窍门来获得高性能。</font></p><p cms-style="font-L"><font cms-style="font-L">简而言之，没有理由不能使您的主CPU成为RISC-V处理器，但这也是一个动力问题。MacOS和Windows已在ARM上运行。至少在短期内，微软或苹果公司是否会花费精力进行另一次硬件过渡似乎值得怀疑。</font></p><p cms-style="font-L"><font cms-style="font-L">这里有很多事情很难猜测。我们看到，例如，现在有人声称RISC-V CPU在功耗和性能方面确实胜过ARM。这也使您想知道RISC-V是否确实有可能成为计算机的中央CPU。</font></p><p cms-style="font-L"><font cms-style="font-L">我必须承认，为什么RISC-V会胜过ARM尚不为人所知。经他们自己承认，RISC-V是一个相当保守的设计。他们使用的指令不多，而其他一些较旧的设计尚未使用过。</font></p><p cms-style="font-L"><font cms-style="font-L">但是，将所有内容配对到最小似乎是一个很大的收获。这使得可以实现非常小的和简单的实现或RISC-V CPU。这再次使得可以减少瓦特使用并增加时钟频率。</font></p><p cms-style="font-L"><font cms-style="font-L">因此，关于RISC-V和ARM的未来，尚未定局。</font></p>
